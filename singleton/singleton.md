## 属性调用

### 类属性和实例属性

类属性所有实例共享， 实例属性每个实例独立， 参考 attribute_levels.py中的代码。

### 属性查找顺序

1. 实例属性
2. 类属性
3. 父类属性
4. 父类的父类属性
... 

具体可以参考 c3_algrithem_test.py 中的代码。

## 单态模式

又称为 Borg 模式，Monostate模式， 所有实例共享同一个状态。

实现方法是，在类中定义一个类属性的字典，所有实例的__dict__ 共享这个字典， 参考 borg.py 中的代码。

## 模块级单例

模块级单例 是Python中 最简单、最自然的单例实现方式 ，利用了Python的模块导入机制。它比基于类的单例模式更简洁，但在需要复杂初始化逻辑时，基于类的单例可能更合适。

见logger_singleton.py 和 test_logger_singleton.py 中的代码。

## new 方法单例模式

在类属性中定义一个类属性 _instance，然后再new方法中判断是否存在实例，如果不存在则创建一个实例，否则返回已存在的实例。参考 singleton_new_method.py 中的代码。

## 装饰器单例模式

装饰器实现单例模式 是一种基于函数的单例实现方式，它利用了Python的函数闭包和装饰器语法。装饰器实现单例模式的核心思想是，在装饰器中定义一个字典，用于存储已创建的实例。当调用被装饰的函数时，先判断字典中是否存在实例，如果不存在则创建一个实例，否则返回已存在的实例。参考 singleton_decorator.py 中的代码。


## 元类单例模式

### 元类对类的影响

元类可以对类的创建过程进行干预， 例如， 可以在类创建时， 自动添加一些属性或方法。 参考 meta_class.py 中的代码。 尤其要注意的是，在元类的控制下，如下方法的顺序：

```sh
    Meta.__call__ start
    TargetClass.__new__
    TargetClass.__init__
    Meta.__call__ end
```


装饰器单例：
在类之外，用闭包和字典把“类”替换成“实例工厂”。

元类单例：
在类之上，用元类的 __call__ 改写“类生成实例的规则”。


## 几种方法的对比

| 对比维度 | `__new__` 实现单例 | 装饰器实现单例 | 元类实现单例 |
|--------|------------------|---------------|-------------|
| 拦截层级 | 实例创建层（对象诞生瞬间） | 类名绑定层（类被替换） | 类调用调度层（类作为可调用对象） |
| 拦截位置 | `Class.__new__` | `@decorator` 返回的新对象 | `Meta.__call__` |
| 类对象是否被替换 | 否 | 是（类名指向函数） | 否 |
| `Class` 是否仍是 `type` 实例 | 是 | 否 | 是 |
| `Class()` 实际调用 | `Class.__new__` → `__init__` | 装饰器返回的函数 | `Meta.__call__` |
| 实例缓存位置 | 类属性 | 装饰器闭包 | 元类属性 |
| 是否影响 `__init__` 调用 | 否（可控） | 是（可能被绕过或重复） | 否（完全受控） |
| 是否支持继承 | 一般（需手动处理） | 差（容易破坏继承） | 好（天然支持） |
| 多子类行为 | 默认共享或混乱 | 基本不可控 | 可精细控制（每类一个实例） |
| 是否符合直觉 | 中等 | 低 | 高 |
| 是否保持“类语义” | 是 | 否 | 是 |
| 侵入性 | 低 | 中（改变类绑定） | 高（引入元类） |
| 可读性 | 好 | 好 | 中 |
| 可维护性 | 中 | 中 | 高 |
| 适用场景 | 简单单例、不可变对象 | 快速实验、小工具 | 框架级、系统级设计 |
| 典型用途 | 配置对象、资源句柄 | 脚本级单例 | ORM、日志器、注册系统 |
| 设计层次 | 对象级 | 语法糖级 | 体系结构级 |
